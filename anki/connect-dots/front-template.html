<!-- Hidden data elements to safely pass Anki fields with special characters -->
<script type="text/template" id="data-left">
  {{Left}}
</script>
<script type="text/template" id="data-right">
  {{Right}}
</script>
<script type="text/template" id="data-fake-right">
  {{Fake Right}}
</script>
<script type="text/template" id="data-key">
  {{Key}}
</script>

<div class="connect-dots-container">
  <div id="error-banner" class="error-banner" style="display: none"></div>
  <div class="columns">
    <div class="column left-column">
      <div class="column-header">Match</div>
      <div id="left-items"></div>
    </div>
    <div class="column right-column">
      <div class="column-header">With</div>
      <div id="right-items"></div>
    </div>
  </div>

  <div class="status-bar">
    <span id="status-text">Tap a left item to start</span>
    <span id="progress">0 / 0</span>
  </div>
</div>

<script>
  (function () {
    // Scroll to top when card opens
    window.scrollTo(0, 0);

    // Clear stale state from previous card (back template no longer clears it,
    // so that re-renders of the back side still find the answers)
    try { sessionStorage.removeItem("connectDotsState"); } catch (e) {}

    // Parse Anki fields from hidden data elements (handles quotes and special chars)
    const leftRaw = document.getElementById("data-left").textContent;
    const rightRaw = document.getElementById("data-right").textContent;
    const fakeRightRaw = document.getElementById("data-fake-right").textContent;
    const keyRaw = document.getElementById("data-key").textContent.trim();

    const leftItems = leftRaw
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s);
    const rightItems = rightRaw
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s);
    const fakeRightItems = fakeRightRaw
      .split(",")
      .map((s) => s.trim())
      .filter((s) => s);

    // Validate item counts match
    if (leftItems.length !== rightItems.length) {
      const banner = document.getElementById("error-banner");
      banner.style.display = "block";
      banner.innerHTML =
        "<strong>Card Error:</strong> Left has " +
        leftItems.length +
        " items, Right has " +
        rightItems.length +
        " items. Please fix this card.";
    }

    // Get unique right items for display (real + fake combined)
    const uniqueRight = [...new Set([...rightItems, ...fakeRightItems])];

    // Shuffle helper
    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // Extract tone number from a pinyin string (1-5, where 5 is neutral)
    function getToneNumber(pinyin) {
      if (/[āēīōūǖĀĒĪŌŪǕ]/.test(pinyin)) return 1;
      if (/[áéíóúǘÁÉÍÓÚǗ]/.test(pinyin)) return 2;
      if (/[ǎěǐǒǔǚǍĚǏǑǓǙ]/.test(pinyin)) return 3;
      if (/[àèìòùǜÀÈÌÒÙǛ]/.test(pinyin)) return 4;
      const numMatch = pinyin.match(/(\d)$/);
      if (numMatch) return parseInt(numMatch[1]);
      return 5; // neutral tone
    }

    // For syllable cards, sort right items by tone; otherwise shuffle
    const isSyllableCard = keyRaw.startsWith("syllable:");
    const shuffledRight = isSyllableCard
      ? [...uniqueRight].sort((a, b) => getToneNumber(a) - getToneNumber(b))
      : shuffle(uniqueRight);

    // Create shuffled indices for left items display order
    const leftIndices = leftItems.map((_, i) => i);
    const shuffledLeftIndices = shuffle(leftIndices);

    // Color palette for connections
    const colors = [
      "#ef4444", // red
      "#10b981", // green
      "#3b82f6", // blue
      "#8b5cf6", // purple
      "#6b7280", // gray
      "#f59e0b", // amber
      "#ec4899", // pink
      "#06b6d4", // cyan
      "#f97316", // orange
      "#14b8a6", // teal
    ];

    // Flip to back - reference: https://github.com/git9527/anki-awesome-select
    function flipToBack() {
      if (typeof pycmd !== "undefined") {
        pycmd("ans");
      } else if (typeof study !== "undefined") {
        study.drawAnswer();
      } else if (typeof AnkiDroidJS !== "undefined") {
        showAnswer();
      } else if (window.anki && window.sendMessage2) {
        window.sendMessage2("ankitap", "midCenter");
      }
    }

    // Detect desktop (non-touch device)
    const isDesktop =
      !("ontouchstart" in window) &&
      window.matchMedia("(min-width: 768px)").matches;

    // State
    let selectedLeftIndices = new Set(); // multiple selection
    let connections = {}; // leftIndex -> rightValue
    let rightUsageCount = {}; // rightValue -> count
    let autoFlipTimeout = null;

    // Initialize usage counts
    shuffledRight.forEach((r) => (rightUsageCount[r] = 0));

    // Check if all items are connected
    function isAllConnected() {
      return Object.keys(connections).length === leftItems.length;
    }

    // Check if clicking a right item will complete all connections
    function willCompleteAllConnections() {
      if (selectedLeftIndices.size === 0) {
        // Auto-connect mode: will this be the last unassigned item?
        const unassignedCount = leftItems.length - Object.keys(connections).length;
        return unassignedCount === 1;
      } else {
        // Selection mode: will connecting all selected complete everything?
        const currentConnected = Object.keys(connections).length;
        return currentConnected + selectedLeftIndices.size === leftItems.length;
      }
    }

    // Render functions
    function getColorForRight(rightValue) {
      const idx = shuffledRight.indexOf(rightValue);
      return colors[idx % colors.length];
    }

    function renderLeft() {
      const container = document.getElementById("left-items");
      container.innerHTML = "";

      // Render left items in shuffled order
      shuffledLeftIndices.forEach((idx) => {
        const item = leftItems[idx];
        const div = document.createElement("div");
        div.className = "item left-item";
        div.dataset.index = idx;

        if (selectedLeftIndices.has(idx)) {
          div.classList.add("selected");
        }

        if (connections[idx] !== undefined) {
          div.classList.add("connected");
          div.style.borderColor = getColorForRight(connections[idx]);
          div.style.backgroundColor = getColorForRight(connections[idx]) + "20";
        }

        const text = document.createElement("span");
        text.className = "item-text";
        text.innerHTML = item;
        div.appendChild(text);

        if (connections[idx] !== undefined) {
          const badge = document.createElement("span");
          badge.className = "connection-badge";
          badge.style.backgroundColor = getColorForRight(connections[idx]);
          badge.innerHTML = connections[idx];
          div.appendChild(badge);
        }

        div.addEventListener("click", (e) => {
          if (!isAllConnected()) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            handleLeftClick(idx);
          }
          // Allow propagation when all connected so tap flips card
        });
        div.addEventListener("touchend", (e) => {
          if (!isAllConnected()) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            handleLeftClick(idx);
          }
          // Allow propagation when all connected so tap flips card
        });
        container.appendChild(div);
      });
    }

    function renderRight() {
      const container = document.getElementById("right-items");
      container.innerHTML = "";

      shuffledRight.forEach((item, idx) => {
        const div = document.createElement("div");
        div.className = "item right-item";
        div.dataset.value = item;
        div.style.borderColor = colors[idx % colors.length];

        if (rightUsageCount[item] > 0) {
          div.classList.add("used");
          div.style.backgroundColor = colors[idx % colors.length] + "20";
        }

        // Show keyboard shortcut number on desktop (1-9 only)
        if (isDesktop && idx < 9) {
          const keyHint = document.createElement("span");
          keyHint.className = "key-hint";
          keyHint.textContent = idx + 1;
          div.appendChild(keyHint);
        }

        const text = document.createElement("span");
        text.className = "item-text";
        text.innerHTML = item;
        div.appendChild(text);

        if (rightUsageCount[item] > 0) {
          const count = document.createElement("span");
          count.className = "usage-count";
          count.style.backgroundColor = colors[idx % colors.length];
          count.textContent = rightUsageCount[item];
          div.appendChild(count);
        }

        div.addEventListener("click", (e) => {
          if (!isAllConnected()) {
            // Don't stop propagation on final tap - let it flip the card (needed for iOS)
            if (!willCompleteAllConnections()) {
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
            }
            handleRightClick(item);
          }
        });
        div.addEventListener("touchend", (e) => {
          if (!isAllConnected()) {
            // Don't stop propagation on final tap - let it flip the card (needed for iOS)
            if (!willCompleteAllConnections()) {
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation();
            }
            handleRightClick(item);
          }
        });
        container.appendChild(div);
      });
    }

    function updateStatus() {
      const connected = Object.keys(connections).length;
      const total = leftItems.length;
      const selected = selectedLeftIndices.size;
      document.getElementById("progress").textContent =
        connected + " / " + total;

      const statusText = document.getElementById("status-text");
      if (selected > 0) {
        statusText.textContent = selected + " selected - tap right to connect";
      } else if (connected === total) {
        statusText.textContent = "All connected! Tap anywhere to flip";
        autoFlipTimeout = setTimeout(flipToBack, 500);
      } else {
        if (autoFlipTimeout) {
          clearTimeout(autoFlipTimeout);
          autoFlipTimeout = null;
        }
        statusText.textContent = "Tap left items to select";
      }
    }

    function handleLeftClick(idx) {
      // If already connected, disconnect it
      if (connections[idx] !== undefined) {
        const oldRight = connections[idx];
        rightUsageCount[oldRight]--;
        delete connections[idx];
        selectedLeftIndices.delete(idx);
      } else if (selectedLeftIndices.has(idx)) {
        // Deselect
        selectedLeftIndices.delete(idx);
      } else {
        // Add to selection
        selectedLeftIndices.add(idx);
      }

      render();
    }

    function handleRightClick(rightValue) {
      // If nothing selected, auto-connect the first unassigned left item
      if (selectedLeftIndices.size === 0) {
        const leftIdx = getFirstUnassignedLeftIndex();
        if (leftIdx === null) return;
        connections[leftIdx] = rightValue;
        rightUsageCount[rightValue]++;
        render();
        return;
      }

      // Connect all selected left items to this right item
      selectedLeftIndices.forEach((idx) => {
        connections[idx] = rightValue;
        rightUsageCount[rightValue]++;
      });
      selectedLeftIndices.clear();

      render();
    }

    function saveState() {
      // Save to sessionStorage for back template to read
      const state = {
        connections: connections,
        leftItems: leftItems,
        rightItems: rightItems,
      };
      try {
        sessionStorage.setItem("connectDotsState", JSON.stringify(state));
      } catch (e) {
        // Fallback: save to a global variable
        window.connectDotsState = state;
      }
    }

    function render() {
      renderLeft();
      renderRight();
      updateStatus();
      saveState();
    }

    // Get first unassigned left item index (in display order)
    function getFirstUnassignedLeftIndex() {
      for (const idx of shuffledLeftIndices) {
        if (connections[idx] === undefined) {
          return idx;
        }
      }
      return null;
    }

    // Keyboard handler for desktop (Ctrl+1-9 or Shift+1-9 assigns first unassigned left to that right item)
    // Plain 1-4 keys are reserved for Anki grading
    if (isDesktop) {
      document.addEventListener("keydown", function (e) {
        if (e.repeat) return; // Ignore key auto-repeat to prevent multiple rapid connections
        if (isAllConnected()) return;
        if (!e.shiftKey && !e.ctrlKey) return; // Require Shift or Ctrl key

        // Shift+1 produces "!" on US keyboard, so check the key code instead
        const numMatch = e.code.match(/^Digit(\d)$/);
        if (numMatch) {
          const num = parseInt(numMatch[1]);
          if (num >= 1 && num <= 9 && num <= shuffledRight.length) {
            e.preventDefault();
            const rightValue = shuffledRight[num - 1];
            const leftIdx = getFirstUnassignedLeftIndex();

            if (leftIdx !== null) {
              connections[leftIdx] = rightValue;
              rightUsageCount[rightValue]++;
              selectedLeftIndices.clear();
              render();
            }
          }
        }
      });
    }

    // Initial render
    render();
  })();
</script>
