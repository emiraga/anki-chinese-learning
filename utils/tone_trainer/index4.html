<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tone Analyzer for Mandarin Practice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      /* Style for the canvas to make it responsive and sharp */
      canvas {
        width: 100%;
        height: 300px;
        background-color: #111827; /* bg-gray-900 */
        border-radius: 0.5rem;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
      /* Custom styles for range sliders */
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 8px;
        background: #4b5563; /* bg-gray-600 */
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      input[type="range"]:hover {
        opacity: 1;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #3b82f6; /* bg-blue-500 */
        cursor: pointer;
        border-radius: 50%;
      }
      input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #3b82f6; /* bg-blue-500 */
        cursor: pointer;
        border-radius: 50%;
      }
    </style>
  </head>
  <body
    class="bg-gray-800 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4"
  >
    <div class="w-full max-w-4xl mx-auto">
      <div class="text-center mb-6">
        <h1 class="text-3xl md:text-4xl font-bold text-white">Tone Analyzer</h1>
        <p class="text-lg text-gray-400 mt-2">
          For practicing Mandarin Chinese pronunciation
        </p>
      </div>

      <!-- Status Message -->
      <div
        id="status"
        class="text-center mb-4 p-3 rounded-lg bg-gray-700 transition-all duration-300"
      >
        <p id="instructions" class="text-lg font-medium text-blue-300">
          Hold the
          <kbd
            class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg"
            >Space</kbd
          >
          key to record
        </p>
      </div>

      <!-- UI Controls -->
      <div
        id="controls"
        class="mt-6 grid grid-cols-1 md:grid-cols-4 gap-6 bg-gray-700/50 p-6 rounded-lg"
      >
        <div class="flex-1/2">
          <button
            id="playAgainBtn"
            class="mt-3 px-4 py-2 bg-blue-800 hover:bg-blue-700 text-gray-300 font-medium rounded-lg transition-colors duration-200 hidden"
            onclick="playLastRecording()"
          >
            ðŸ”Š Play Audio
          </button>
        </div>
        <div>
          <label
            for="colorScheme"
            class="block mb-2 text-sm font-medium text-gray-300"
            >Color Scheme</label
          >
          <select
            id="colorScheme"
            class="bg-gray-600 border border-gray-500 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-1"
          >
            <option value="viridis">Viridis</option>
            <option value="plasma">Plasma</option>
            <option value="hot">Hot</option>
            <option value="grayscale">Grayscale</option>
          </select>
        </div>
        <div>
          <label
            for="brightness"
            class="block mb-2 text-sm font-medium text-gray-300"
            >Brightness</label
          >
          <input
            type="range"
            id="brightness"
            min="-100"
            max="100"
            value="0"
            class="w-full"
          />
        </div>
        <div>
          <label
            for="contrast"
            class="block mb-2 text-sm font-medium text-gray-300"
            >Contrast</label
          >
          <input
            type="range"
            id="contrast"
            min="0"
            max="5"
            value="1.5"
            step="0.1"
            class="w-full"
          />
        </div>
      </div>

      <!-- Spectrogram Canvas with YIN Pitch Overlay -->
      <div class="w-full bg-gray-900 rounded-lg shadow-lg p-2 relative">
        <h3 class="text-white text-lg font-medium mb-2 px-2">
          Spectrogram with YIN Pitch Overlay
        </h3>
        <div class="relative">
          <canvas id="spectrogramCanvas"></canvas>
          <canvas
            id="yinPitchCanvas"
            class="absolute top-0 left-0 pointer-events-none"
            style="background: transparent"
          ></canvas>
        </div>
        <div
          id="loadingOverlay"
          class="absolute inset-0 bg-gray-900/80 flex items-center justify-center rounded-lg hidden"
        >
          <div class="text-center">
            <div
              class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-2"
            ></div>
            <p class="text-gray-300 text-sm">Computing charts...</p>
          </div>
        </div>
        <div
          id="yinPitchLoadingOverlay"
          class="absolute inset-0 bg-gray-900/80 flex items-center justify-center rounded-lg hidden"
        >
          <div class="text-center">
            <div
              class="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500 mx-auto mb-2"
            ></div>
            <p class="text-gray-300 text-sm">Computing YIN pitch...</p>
          </div>
        </div>
        <!-- <div
          class="grid grid-cols-2 md:grid-cols-2 gap-4 mt-3 text-xs text-gray-400"
        >
          <div class="text-center">
            <div class="text-yellow-400 font-medium">Threshold</div>
            <div id="yinThreshold">-</div>
          </div>
          <div class="text-center">
            <div class="text-purple-400 font-medium">YIN Pitch</div>
            <div id="yinPitchValue">-</div>
          </div>
        </div> -->
      </div>

      <!-- YIN Algorithm Controls -->
      <div
        id="yinControls"
        class="mt-4 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 bg-gray-700/50 p-4 rounded-lg hidden"
      >
        <div>
          <label
            for="yinFrameSize"
            class="block mb-2 text-xs font-medium text-gray-300"
            >Frame Size</label
          >
          <select
            id="yinFrameSize"
            class="bg-gray-600 border border-gray-500 text-white text-xs rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-1"
          >
            <option value="16">16</option>
            <option value="32">32</option>
            <option value="64">64</option>
            <option value="128">128</option>
            <option value="256">256</option>
            <option value="512">512</option>
            <option value="1024" selected>1024</option>
            <option value="2048">2048</option>
            <option value="4096">4096</option>
          </select>
        </div>
        <div>
          <label
            for="yinHopSize"
            class="block mb-2 text-xs font-medium text-gray-300"
            >Hop Size</label
          >
          <select
            id="yinHopSize"
            class="bg-gray-600 border border-gray-500 text-white text-xs rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-1"
          >
            <option value="4">4</option>
            <option value="8">8</option>
            <option value="16">16</option>
            <option value="32" selected>32</option>
            <option value="64">64</option>
            <option value="128">128</option>
            <option value="256">256</option>
            <option value="512">512</option>
            <option value="1024">1024</option>
            <option value="2048">2048</option>
            <option value="4096">4096</option>
          </select>
        </div>
        <div>
          <label
            for="yinThreshold"
            class="block mb-2 text-xs font-medium text-gray-300"
            >Threshold</label
          >
          <input
            type="range"
            id="yinThresholdSlider"
            min="0.05"
            max="0.5"
            value="0.30"
            step="0.01"
            class="w-full"
          />
          <div
            class="text-xs text-gray-400 text-center mt-1"
            id="yinThresholdValue"
          >
            0.30
          </div>
        </div>
        <div>
          <label
            for="yinMinFreq"
            class="block mb-2 text-xs font-medium text-gray-300"
            >Min Freq (Hz)</label
          >
          <input
            type="range"
            id="yinMinFreqSlider"
            min="10"
            max="200"
            value="30"
            step="5"
            class="w-full"
          />
          <div
            class="text-xs text-gray-400 text-center mt-1"
            id="yinMinFreqValue"
          >
            10
          </div>
        </div>
        <div>
          <label
            for="yinMaxFreq"
            class="block mb-2 text-xs font-medium text-gray-300"
            >Max Freq (Hz)</label
          >
          <input
            type="range"
            id="yinMaxFreqSlider"
            min="100"
            max="1000"
            value="300"
            step="10"
            class="w-full"
          />
          <div
            class="text-xs text-gray-400 text-center mt-1"
            id="yinMaxFreqValue"
          >
            300
          </div>
        </div>
        <div class="flex items-center">
          <input
            type="checkbox"
            id="yinInterpolation"
            checked
            class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
          />
          <label
            for="yinInterpolation"
            class="ml-2 text-xs font-medium text-gray-300"
            >Parabolic Interpolation</label
          >
        </div>
      </div>

      <!-- YIN Analysis Chart -->
      <!-- <div class="w-full bg-gray-900 rounded-lg shadow-lg p-2 mt-4">
        <h3 class="text-white text-lg font-medium mb-2 px-2">
          YIN Analysis (Difference, CMND)
        </h3>
        <canvas id="yinCanvas"></canvas>
        <div
          class="grid grid-cols-2 md:grid-cols-2 gap-4 mt-3 text-xs text-gray-400"
        >
          <div class="text-center">
            <div class="text-blue-400 font-medium">Difference Function</div>
            <div id="yinDiffValue">-</div>
          </div>
          <div class="text-center">
            <div class="text-green-400 font-medium">CMND Function</div>
            <div id="yinCmndValue">-</div>
          </div>
        </div>
      </div> -->

      <!-- Audio Strength Chart -->
      <!-- <div class="w-full bg-gray-900 rounded-lg shadow-lg p-2 mt-4">
        <h3 class="text-white text-lg font-medium mb-2 px-2">
          Audio Strength Over Time
        </h3>
        <canvas id="strengthCanvas"></canvas>
      </div> -->
    </div>

    <script>
      // Preloaded audio data
      const PRELOADED_AUDIO_DATA =
        "data:audio/mpeg;base64,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4U0dDUteQrZdnYpJsM9Mqht5hEPOzFLU1Fo7DWc7TV31f2llMNSLPY0PSAVCMDwAIPqNQo4QWFQ9gWE8qVBz4szDGmFNQWu9//OExOssjBn4ANpM3S1VrYWFvcVNRolmWP3WMq5Jr1vqtj5LORIomkSOf7LVTU5oBCVNJwCRcFAKL4cSl3w7wDALGNCcrkiUJekj5xq28pvjsccdWy+Thy3n9n6XeDqN7MSqqSrDUXrd/30SpqJb5RzHzdaqrcJJFrmWfMaaY4lyQVUpfnwuxG527AmMbsSWiuv58czmam4IgIrWKyB5hZDZDMqOWS2heuPrMzw+8flrMj8ye4mYsWRxxjVFinpA//OExOsrXCnoANoM3fOUpGJSa0VEPTWkyozttYtkF9aCck7a4L55XLMNSPJZUqT60HmyHPQLixGFFSdYEoo3SWHDOjal0MdScLYLmEzk6B9Nuj3F2jGGuBpwUx0HroCY7EEaETCKCPsa6MKSPHYo5APYXB8mJuA0C1HiOLg1rAoEHSc4MgcRs5ySDI2LKU5M0mdLy9esSnKVy21M1Jdeu0u6csUPkBQmoknZJZ6jAqRCRulg0EDnQgFySXDQagYj//OExPAvRDHUAOJM3aa7qi5AnTN0nJ2659Xg48pOkaXTum8gTIJSU8obhWRYYo54WoxFnT9EatBkS3J95tyoojp8VdvLSwdyk4xjohK44r4cyuam53l5VEJAeaE1aBc4WWSLgdQHFTqSUyQWRBrxc9oOPiiJRg6WnHiUiLHqoi2l91aaVUo+8ak+cjiQtL3JqOhZl7tuW19nDOGGLsYYwxnDWHIAGCYrFaNuUki5cjIwuFwuKw2GBQSGDDDnRqlF//OExOYsLDnYAOGM3BgkJCQwbJyc2bRrznUpa8cWLFgAAABAgQICBB6pSIEBBw4cOHDhw7oMRKq2ggSIiCBAw4445mepmY44sWOOIRESSMpERIiIHBg64O0/ttoOogREREIzNmmkc3dxxw9Qh+1lAAAAA8vfptYfWHkAChT6IBAQHjw8et9089UzMg46oyYwxogwYABAi2yAZFZYViLXYdluNIiIUhUEQCgBACAEAIBQSBIVCpEilvksiRCoVCoV//OExOgsCxHYAOJGuQqFIpFKFChZjH+KgICAgICBAQEBAQEBCmUvZmYCCgICAgICAgIVmb9VVmYCAgICAgyqql/FVVVVUKFBQV/wgoKCgUFBQV3xQUFCgoKCgn/hBQKCgoKDHf+IUFBQUEgrv/EFBQUGCgp//CCgoJBQUFd/xQUGCgoKCkxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//OExOorwfnUANJGmVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";

      // DOM Elements
      const instructions = document.getElementById("instructions");
      const statusDiv = document.getElementById("status");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const canvas = document.getElementById("spectrogramCanvas");
      const canvasCtx = canvas.getContext("2d");
      // const strengthCanvas = document.getElementById("strengthCanvas");
      // const strengthCanvasCtx = strengthCanvas.getContext("2d");
      // const yinCanvas = document.getElementById("yinCanvas");
      // const yinCanvasCtx = yinCanvas.getContext("2d");
      const yinPitchCanvas = document.getElementById("yinPitchCanvas");
      const yinPitchCanvasCtx = yinPitchCanvas.getContext("2d");
      const controls = document.getElementById("controls");
      const colorSchemeSelect = document.getElementById("colorScheme");
      const brightnessSlider = document.getElementById("brightness");
      const contrastSlider = document.getElementById("contrast");
      const loadingOverlay = document.getElementById("loadingOverlay");
      const yinPitchLoadingOverlay = document.getElementById(
        "yinPitchLoadingOverlay"
      );

      // Audio & State Variables
      let audioContext;
      let mediaRecorder;
      let isRecording = false;
      let audioChunks = [];
      let spectrogramData = [];
      let pitchData = [];
      let strengthData = [];
      let yinData = [];
      let lastAudioBuffer = null;

      // Visualization Settings
      let settings = {
        colorScheme: "viridis",
        brightness: 0,
        contrast: 1.5,
      };

      // YIN Algorithm Parameters
      let yinParams = {
        frameSize: 1024, // Window size for analysis
        hopSize: 32, // Step size between frames
        threshold: 0.3, // Absolute threshold for period detection
        minFreq: 30, // Minimum frequency to consider (Hz)
        maxFreq: 300, // Maximum frequency to consider (Hz)
        interpolation: true, // Enable parabolic interpolation
      };

      // --- ANALYSIS CONSTANTS (EDITED FOR HIGHER RESOLUTION) ---
      // Increased FFT_SIZE for better frequency (vertical) resolution.
      const FFT_SIZE = 4096 * 2;
      // The maximum frequency (in Hz) to display. This focuses the view on the vocal range.
      const MAX_FREQ_HZ = 1300;
      // is about how often we do the analysis. The system collects audio into a buffer, and every time the buffer is full, it runs the analysis.
      const BUFFER_SIZE = 256;

      // --- COLOR MAPS ---
      const COLOR_MAPS = {
        viridis: [
          [68, 1, 84],
          [72, 40, 120],
          [62, 74, 137],
          [49, 104, 142],
          [38, 130, 142],
          [31, 158, 137],
          [53, 183, 121],
          [109, 205, 89],
          [180, 222, 44],
          [253, 231, 37],
        ],
        plasma: [
          [13, 8, 135],
          [72, 1, 163],
          [120, 1, 168],
          [163, 29, 151],
          [201, 62, 122],
          [230, 99, 90],
          [249, 139, 64],
          [254, 183, 43],
          [240, 226, 33],
        ],
        hot: [
          [0, 0, 0],
          [255, 0, 0],
          [255, 255, 0],
          [255, 255, 255],
        ],
        grayscale: [
          [0, 0, 0],
          [255, 255, 255],
        ],
      };

      function interpolateColor(c1, c2, factor) {
        const result = c1.slice();
        for (let i = 0; i < 3; i++) {
          result[i] = Math.round(result[i] + factor * (c2[i] - result[i]));
        }
        return result;
      }

      function getColor(value, schemeName) {
        const map = COLOR_MAPS[schemeName];
        const scaledValue = (value / 255) * (map.length - 1);
        const colorIndex = Math.floor(scaledValue);
        const factor = scaledValue - colorIndex;

        if (colorIndex >= map.length - 1) {
          return map[map.length - 1];
        }
        return interpolateColor(map[colorIndex], map[colorIndex + 1], factor);
      }

      // --- PITCH DETECTION FROM SPECTROGRAM DATA ---
      function computeWeightedAverageFreq(freqData, sampleRate) {
        // Focus on vocal fundamental frequency range (80-400 Hz)
        const minFreq = 30;
        const maxFreq = MAX_FREQ_HZ;
        const fftSize = FFT_SIZE;

        const minBin = Math.floor((minFreq * fftSize) / sampleRate);
        const maxBin = Math.floor((maxFreq * fftSize) / sampleRate);

        let weightedSum = 0;
        let totalWeight = 0;
        let maxMagnitude = 0;

        // Find maximum in range for thresholding
        for (let i = minBin; i < maxBin && i < freqData.length; i++) {
          if (freqData[i] > maxMagnitude) {
            maxMagnitude = freqData[i];
          }
        }

        // Only consider frequencies above threshold
        const threshold = maxMagnitude * 0.3;

        for (let i = minBin; i < maxBin && i < freqData.length; i++) {
          if (freqData[i] > threshold) {
            const freq = (i * sampleRate) / fftSize;
            const magnitude = freqData[i];

            weightedSum += freq * magnitude * magnitude; // Square for emphasis
            totalWeight += magnitude * magnitude;
          }
        }

        if (totalWeight > 0 && maxMagnitude > 20) {
          // Minimum energy threshold
          return weightedSum / totalWeight;
        }

        return 0; // No clear pitch
      }

      function analyzePitchTrends(pitches) {
        const validPitches = pitches.filter((p) => p > 0);
        if (validPitches.length < 5) return { avgPitch: 0, range: 0 };

        const avgPitch =
          validPitches.reduce((a, b) => a + b, 0) / validPitches.length;
        const minPitch = Math.min(...validPitches);
        const maxPitch = Math.max(...validPitches);
        const range = maxPitch - minPitch;

        // Calculate overall trend using linear regression
        let sumX = 0,
          sumY = 0,
          sumXY = 0,
          sumXX = 0;
        let n = 0;

        for (let i = 0; i < pitches.length; i++) {
          if (pitches[i] > 0) {
            sumX += i;
            sumY += pitches[i];
            sumXY += i * pitches[i];
            sumXX += i * i;
            n++;
          }
        }

        if (n < 2) return { avgPitch, range };

        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);

        return { avgPitch, range, slope };
      }

      // --- YIN ALGORITHM IMPLEMENTATION ---
      function yinDifferenceFunction(buffer) {
        const bufferSize = buffer.length;
        const differenceFunction = new Array(bufferSize / 2);

        // Step 1: Difference function d_t(Ï„) = Î£(x_j - x_{j+Ï„})Â²
        for (let tau = 0; tau < bufferSize / 2; tau++) {
          let sum = 0;
          for (let j = 0; j < bufferSize / 2; j++) {
            const delta = buffer[j] - buffer[j + tau];
            sum += delta * delta;
          }
          differenceFunction[tau] = sum;
        }

        return differenceFunction;
      }

      function yinCumulativeMeanNormalizedDifference(differenceFunction) {
        const cmndf = new Array(differenceFunction.length);
        cmndf[0] = 1;

        // Step 2: Cumulative mean normalized difference function
        // d'_t(Ï„) = { 1 if Ï„ = 0
        //           { d_t(Ï„) / ((1/Ï„) * Î£_{j=1}^Ï„ d_t(j)) if Ï„ â‰  0
        let runningSum = 0;
        for (let tau = 1; tau < differenceFunction.length; tau++) {
          runningSum += differenceFunction[tau];
          cmndf[tau] = differenceFunction[tau] / (runningSum / tau);
        }

        return cmndf;
      }

      function yinAbsoluteThreshold(cmndf, threshold) {
        // Step 3: Absolute threshold
        // Find the first minimum below the threshold
        for (let tau = 2; tau < cmndf.length; tau++) {
          if (cmndf[tau] < threshold) {
            // Check if this is a local minimum
            while (tau + 1 < cmndf.length && cmndf[tau + 1] < cmndf[tau]) {
              tau++;
            }
            return tau;
          }
        }
        return -1; // No period found
      }

      function yinParabolicInterpolation(cmndf, tauEstimate) {
        // Step 4: Parabolic interpolation for better accuracy
        if (tauEstimate < 1 || tauEstimate >= cmndf.length - 1) {
          return tauEstimate;
        }

        const s0 = cmndf[tauEstimate - 1];
        const s1 = cmndf[tauEstimate];
        const s2 = cmndf[tauEstimate + 1];

        // Parabolic interpolation formula
        const betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
        return betterTau;
      }

      function performYinAnalysis(audioBuffer, frameSize, hopSize) {
        // Use parameters from yinParams if not provided
        frameSize = frameSize || yinParams.frameSize;
        hopSize = hopSize || yinParams.hopSize;

        const sampleRate = audioBuffer.sampleRate;
        const audioData = audioBuffer.getChannelData(0);
        const yinResults = [];

        // Process audio in overlapping frames
        for (let i = 0; i <= audioData.length - frameSize; i += hopSize) {
          const frame = audioData.slice(i, i + frameSize);

          // Step 1: Difference function
          const differenceFunction = yinDifferenceFunction(frame);

          // Step 2: Cumulative mean normalized difference function
          const cmndf =
            yinCumulativeMeanNormalizedDifference(differenceFunction);

          // Step 3: Absolute threshold
          let tauEstimate = yinAbsoluteThreshold(cmndf, yinParams.threshold);

          let pitch = 0;
          let confidence = 0;

          if (tauEstimate > 0) {
            // Step 4: Parabolic interpolation (if enabled)
            const betterTau = yinParams.interpolation
              ? yinParabolicInterpolation(cmndf, tauEstimate)
              : tauEstimate;

            // Convert tau to frequency
            pitch = sampleRate / betterTau;

            // Confidence is inverse of CMNDF value at the estimated tau
            confidence = 1 - cmndf[Math.round(betterTau)];

            // Filter out unrealistic pitches using dynamic parameters
            if (pitch < yinParams.minFreq || pitch > yinParams.maxFreq) {
              pitch = 0;
              confidence = 0;
            }
          }

          yinResults.push({
            pitch: pitch,
            confidence: confidence,
            differenceFunction: differenceFunction.slice(0, 200), // Store first 200 points for visualization
            cmndf: cmndf.slice(0, 200),
            tau: tauEstimate,
            threshold: yinParams.threshold,
            timeIndex: i / sampleRate,
          });
        }

        return yinResults;
      }

      // --- EVENT LISTENERS ---
      window.addEventListener("load", () => {
        controls.style.display = "none";
        // Automatically load and process the preloaded audio
        loadPreloadedAudio();
      });

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault(); // Always prevent space bar scrolling
          if (!isRecording) {
            startRecording();
          }
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          e.preventDefault(); // Always prevent space bar scrolling
          if (isRecording) {
            stopRecording();
          }
        }
      });

      colorSchemeSelect.addEventListener("change", (e) => {
        settings.colorScheme = e.target.value;
        if (spectrogramData.length > 0) {
          drawSpectrogram();
          drawStrengthChart();
          drawYinChart();
          drawYinPitchChart();
        }
      });
      brightnessSlider.addEventListener("input", (e) => {
        settings.brightness = parseInt(e.target.value, 10);
        if (spectrogramData.length > 0) {
          drawSpectrogram();
          drawStrengthChart();
          drawYinChart();
          drawYinPitchChart();
        }
      });
      contrastSlider.addEventListener("input", (e) => {
        settings.contrast = parseFloat(e.target.value);
        if (spectrogramData.length > 0) {
          drawSpectrogram();
          drawStrengthChart();
          drawYinChart();
          drawYinPitchChart();
        }
      });

      // --- YIN PARAMETER EVENT LISTENERS ---
      function recomputeYin() {
        if (lastAudioBuffer && yinData.length > 0) {
          showYinPitchLoadingOverlay();
          // Use setTimeout to allow overlay to show before heavy computation
          setTimeout(() => {
            yinData = performYinAnalysis(lastAudioBuffer);
            drawYinChart();
            drawYinPitchChart();
            hideYinPitchLoadingOverlay();
          }, 10);
        }
      }

      function showYinPitchLoadingOverlay() {
        yinPitchLoadingOverlay.classList.remove("hidden");
      }

      function hideYinPitchLoadingOverlay() {
        yinPitchLoadingOverlay.classList.add("hidden");
      }

      document
        .getElementById("yinFrameSize")
        .addEventListener("change", (e) => {
          yinParams.frameSize = parseInt(e.target.value, 10);
          recomputeYin();
        });

      document.getElementById("yinHopSize").addEventListener("change", (e) => {
        yinParams.hopSize = parseInt(e.target.value, 10);
        recomputeYin();
      });

      document
        .getElementById("yinThresholdSlider")
        .addEventListener("input", (e) => {
          yinParams.threshold = parseFloat(e.target.value);
          document.getElementById("yinThresholdValue").textContent =
            yinParams.threshold.toFixed(2);
          recomputeYin();
        });

      document
        .getElementById("yinMinFreqSlider")
        .addEventListener("input", (e) => {
          yinParams.minFreq = parseInt(e.target.value, 10);
          document.getElementById("yinMinFreqValue").textContent =
            yinParams.minFreq;
          recomputeYin();
        });

      document
        .getElementById("yinMaxFreqSlider")
        .addEventListener("input", (e) => {
          yinParams.maxFreq = parseInt(e.target.value, 10);
          document.getElementById("yinMaxFreqValue").textContent =
            yinParams.maxFreq;
          recomputeYin();
        });

      document
        .getElementById("yinInterpolation")
        .addEventListener("change", (e) => {
          yinParams.interpolation = e.target.checked;
          recomputeYin();
        });

      // --- CORE AUDIO FUNCTIONS ---
      async function startRecording() {
        if (isRecording) return;
        isRecording = true;
        audioChunks = [];

        statusDiv.classList.remove("bg-gray-700");
        statusDiv.classList.add("bg-red-500");
        instructions.textContent = "Recording...";

        try {
          // Ensure AudioContext is created by user gesture
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };
          mediaRecorder.onstop = processAudio;
          mediaRecorder.start();
        } catch (err) {
          console.error("Error accessing microphone:", err);
          instructions.textContent =
            "Microphone access denied. Please allow access and try again.";
          statusDiv.classList.remove("bg-red-500");
          statusDiv.classList.add("bg-yellow-600");
          isRecording = false;
        }
      }

      function stopRecording() {
        if (!isRecording || !mediaRecorder) return;
        mediaRecorder.stop();

        // Clean up media stream tracks
        if (mediaRecorder.stream) {
          mediaRecorder.stream.getTracks().forEach((track) => track.stop());
        }

        isRecording = false;
        statusDiv.classList.remove("bg-red-500");
        statusDiv.classList.add("bg-blue-500");
        instructions.textContent = "Analyzing...";
      }

      function processAudio() {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const audioBuffer = await audioContext.decodeAudioData(
              e.target.result
            );
            // Initialize data arrays (will be filled during spectrogram analysis)
            pitchData = [];
            strengthData = [];
            yinData = [];
            lastAudioBuffer = audioBuffer; // Store for replay

            // Perform YIN analysis
            yinData = performYinAnalysis(audioBuffer);

            analyzeAndDraw(audioBuffer);
            playAudio(audioBuffer);
          } catch (err) {
            console.error("Error decoding audio data:", err);
            instructions.textContent =
              "Could not process audio. Please try again.";
          }
        };
        reader.readAsArrayBuffer(audioBlob);
      }

      function playAudio(audioBuffer) {
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start(0);
      }

      function playLastRecording() {
        if (lastAudioBuffer && audioContext) {
          playAudio(lastAudioBuffer);
        }
      }

      async function loadPreloadedAudio() {
        try {
          // Initialize audio context if not already done
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }

          // Convert base64 data URL to array buffer
          const response = await fetch(PRELOADED_AUDIO_DATA);
          const arrayBuffer = await response.arrayBuffer();

          // Decode audio data
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          // Store as last audio buffer for playback
          lastAudioBuffer = audioBuffer;

          // Initialize data arrays
          pitchData = [];
          strengthData = [];
          yinData = [];

          // Perform YIN analysis
          yinData = performYinAnalysis(audioBuffer);

          // Analyze and draw visualizations
          analyzeAndDraw(audioBuffer);

          // Update UI to show that audio is loaded
          statusDiv.classList.remove("bg-gray-700");
          // statusDiv.classList.add("bg-green-600");
          instructions.innerHTML =
            'Preloaded audio ready! Click <button class="px-2 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm" onclick="playLastRecording()">ðŸ”Š Play</button> or hold <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Space</kbd> to record';

          // Show controls and play button
          controls.style.display = "grid";
          document.getElementById("yinControls").classList.remove("hidden");
          playAgainBtn.classList.remove("hidden");
        } catch (err) {
          console.error("Error loading preloaded audio:", err);
          instructions.textContent =
            "Error loading preloaded audio. Hold Space to record your own.";
          statusDiv.classList.remove("bg-gray-700");
          statusDiv.classList.add("bg-yellow-600");
        }
      }

      function analyzeAndDraw(audioBuffer) {
        const offlineCtx = new OfflineAudioContext(
          audioBuffer.numberOfChannels,
          audioBuffer.length,
          audioBuffer.sampleRate
        );
        const source = offlineCtx.createBufferSource();
        source.buffer = audioBuffer;

        const analyser = offlineCtx.createAnalyser();
        analyser.fftSize = FFT_SIZE; // Use the new higher resolution FFT size
        analyser.smoothingTimeConstant = 0;

        // Decreased buffer size for better time (horizontal) resolution.
        const bufferSize = BUFFER_SIZE;
        const processor = offlineCtx.createScriptProcessor(bufferSize, 1, 1);

        const freqData = new Uint8Array(analyser.frequencyBinCount);
        spectrogramData = [];

        processor.onaudioprocess = (e) => {
          analyser.getByteFrequencyData(freqData);
          spectrogramData.push(new Uint8Array(freqData));

          // Compute weighted average frequency for pitch
          const pitch = computeWeightedAverageFreq(
            freqData,
            audioContext.sampleRate
          );
          pitchData.push(pitch);

          // Compute RMS (audio strength) from time domain data
          const inputData = e.inputBuffer.getChannelData(0);
          const rms = Math.sqrt(
            inputData.reduce((sum, val) => sum + val * val, 0) /
              inputData.length
          );
          strengthData.push(rms);
        };

        source.connect(analyser);
        analyser.connect(processor);
        processor.connect(offlineCtx.destination);

        source.start(0);

        offlineCtx
          .startRendering()
          .then(() => {
            console.log(
              `Analysis complete. Got ${spectrogramData.length} time slices.`
            );
            statusDiv.classList.remove("bg-blue-500");
            statusDiv.classList.add("bg-gray-700");
            instructions.innerHTML =
              'Hold the <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Space</kbd> key to record';
            controls.style.display = "grid";
            document.getElementById("yinControls").classList.remove("hidden");

            drawSpectrogram();
            drawStrengthChart();
            drawYinChart();
            drawYinPitchChart();

            playAgainBtn.classList.remove("hidden"); // Show play again button
          })
          .catch((err) => {
            console.error("Offline rendering failed:", err);
            instructions.textContent = "Error during analysis.";
          });
      }

      function drawSpectrogram() {
        const numSlices = spectrogramData.length;
        if (numSlices === 0) return;

        // --- EDITED FOR FOCUSED VIEW ---
        // Calculate how many frequency bins to show to focus on the vocal range.
        const freqPerBin = audioContext.sampleRate / FFT_SIZE;
        const relevantBins = Math.ceil(MAX_FREQ_HZ / freqPerBin);
        const totalBins = spectrogramData[0].length;
        const finalBinsToDraw = Math.min(relevantBins, totalBins);

        canvas.width = numSlices;
        canvas.height = finalBinsToDraw;

        const imageData = canvasCtx.createImageData(
          canvas.width,
          canvas.height
        );
        const data = imageData.data;

        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const value = spectrogramData[x][y];
            const color = getColor(value, settings.colorScheme);

            let r =
              settings.contrast * (color[0] - 128) + 128 + settings.brightness;
            let g =
              settings.contrast * (color[1] - 128) + 128 + settings.brightness;
            let b =
              settings.contrast * (color[2] - 128) + 128 + settings.brightness;

            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            const pixelIndex = ((canvas.height - 1 - y) * canvas.width + x) * 4;
            data[pixelIndex] = r;
            data[pixelIndex + 1] = g;
            data[pixelIndex + 2] = b;
            data[pixelIndex + 3] = 255;
          }
        }
        canvasCtx.putImageData(imageData, 0, 0);
      }

      function drawStrengthChart() {
        return;
        if (strengthData.length === 0) return;

        // Set canvas size
        strengthCanvas.width = strengthCanvas.offsetWidth;
        strengthCanvas.height = 120;

        const ctx = strengthCanvasCtx;
        const width = strengthCanvas.width;
        const height = strengthCanvas.height;

        // Clear canvas
        ctx.fillStyle = "#111827";
        ctx.fillRect(0, 0, width, height);

        // Analyze strength data
        const maxStrength = Math.max(...strengthData);

        if (maxStrength === 0) {
          ctx.fillStyle = "#9CA3AF";
          ctx.font = "16px Inter";
          ctx.textAlign = "center";
          ctx.fillText("No audio signal detected", width / 2, height / 2);
          return;
        }

        // Draw grid lines
        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 1; i < 4; i++) {
          const y = (height / 4) * i;
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
        }
        ctx.stroke();

        // Draw strength bars
        const barWidth = width / strengthData.length;

        for (let i = 0; i < strengthData.length; i++) {
          const x = i * barWidth;
          const barHeight = (strengthData[i] / maxStrength) * height;
          const y = height - barHeight;

          // Color based on strength level
          const strengthRatio = strengthData[i] / maxStrength;
          let color;
          if (strengthRatio > 0.7) {
            color = "#EF4444"; // Red for loud
          } else if (strengthRatio > 0.3) {
            color = "#F59E0B"; // Yellow for medium
          } else {
            color = "#10B981"; // Green for quiet
          }

          ctx.fillStyle = color;
          ctx.fillRect(x, y, barWidth - 1, barHeight);
        }
      }

      function drawYinChart() {
        return;
        if (yinData.length === 0) return;

        // Set canvas size
        yinCanvas.width = yinCanvas.offsetWidth;
        yinCanvas.height = 200;

        const ctx = yinCanvasCtx;
        const width = yinCanvas.width;
        const height = yinCanvas.height;

        // Clear canvas
        ctx.fillStyle = "#111827";
        ctx.fillRect(0, 0, width, height);

        // Calculate average YIN data for visualization
        const avgFrame = yinData[Math.floor(yinData.length / 2)];
        if (!avgFrame) return;

        // Update UI indicators
        const yinDiffValue = document.getElementById("yinDiffValue");
        const yinCmndValue = document.getElementById("yinCmndValue");

        yinDiffValue.textContent = `Min: ${Math.min(
          ...avgFrame.differenceFunction
        ).toFixed(2)}`;
        yinCmndValue.textContent = `Min: ${Math.min(...avgFrame.cmndf).toFixed(
          3
        )}`;

        // Draw two sections: Difference Function and CMNDF
        const sectionHeight = height / 2;

        // Section 1: Difference Function
        ctx.fillStyle = "#1F2937";
        ctx.fillRect(0, 0, width, sectionHeight);

        ctx.fillStyle = "#3B82F6";
        ctx.font = "12px Inter";
        ctx.textAlign = "left";
        ctx.fillText("Difference Function", 10, 20);

        if (
          avgFrame.differenceFunction &&
          avgFrame.differenceFunction.length > 0
        ) {
          const maxDiff = Math.max(...avgFrame.differenceFunction);
          ctx.strokeStyle = "#3B82F6";
          ctx.lineWidth = 1;
          ctx.beginPath();

          for (let i = 0; i < avgFrame.differenceFunction.length; i++) {
            const x = (i / avgFrame.differenceFunction.length) * width;
            const y =
              sectionHeight -
              (avgFrame.differenceFunction[i] / maxDiff) * (sectionHeight - 30);

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }

        // Section 2: CMNDF
        ctx.fillStyle = "#1F2937";
        ctx.fillRect(0, sectionHeight, width, sectionHeight);

        ctx.fillStyle = "#10B981";
        ctx.font = "12px Inter";
        ctx.textAlign = "left";
        ctx.fillText(
          "Cumulative Mean Normalized Difference Function",
          10,
          sectionHeight + 20
        );

        // Draw threshold line
        const thresholdY =
          sectionHeight +
          sectionHeight -
          avgFrame.threshold * (sectionHeight - 30);
        ctx.strokeStyle = "#F59E0B";
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, thresholdY);
        ctx.lineTo(width, thresholdY);
        ctx.stroke();
        ctx.setLineDash([]);

        if (avgFrame.cmndf && avgFrame.cmndf.length > 0) {
          ctx.strokeStyle = "#10B981";
          ctx.lineWidth = 2;
          ctx.beginPath();

          for (let i = 0; i < avgFrame.cmndf.length; i++) {
            const x = (i / avgFrame.cmndf.length) * width;
            const y =
              sectionHeight +
              sectionHeight -
              Math.min(avgFrame.cmndf[i], 1) * (sectionHeight - 30);

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();

          // Mark the detected period with a red dot
          if (avgFrame.tau > 0 && avgFrame.tau < avgFrame.cmndf.length) {
            const tauX = (avgFrame.tau / avgFrame.cmndf.length) * width;
            const tauY =
              sectionHeight +
              sectionHeight -
              Math.min(avgFrame.cmndf[avgFrame.tau], 1) * (sectionHeight - 30);

            ctx.fillStyle = "#EF4444";
            ctx.beginPath();
            ctx.arc(tauX, tauY, 4, 0, 2 * Math.PI);
            ctx.fill();
          }
        }

        // Draw section divider
        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, sectionHeight);
        ctx.lineTo(width, sectionHeight);
        ctx.stroke();
      }

      function drawYinPitchChart() {
        if (yinData.length === 0) return;

        // Set high resolution canvas dimensions to match spectrogram
        const displayWidth = yinPitchCanvas.offsetWidth;
        const displayHeight = yinPitchCanvas.offsetHeight;
        const pixelRatio = window.devicePixelRatio || 1;

        yinPitchCanvas.width = displayWidth * pixelRatio;
        yinPitchCanvas.height = displayHeight * pixelRatio;

        // Scale context to ensure correct drawing operations
        yinPitchCanvasCtx.scale(pixelRatio, pixelRatio);

        // Set CSS size to maintain display size
        yinPitchCanvas.style.width = displayWidth + "px";
        yinPitchCanvas.style.height = displayHeight + "px";

        const ctx = yinPitchCanvasCtx;
        const width = displayWidth;
        const height = displayHeight;

        // Clear canvas with transparent background
        ctx.clearRect(0, 0, width, height);

        // Calculate average YIN data for visualization
        const avgFrame = yinData[Math.floor(yinData.length / 2)];
        if (!avgFrame) return;

        // Update UI indicators
        // const yinThreshold = document.getElementById("yinThreshold");
        // const yinPitchValue = document.getElementById("yinPitchValue");

        const avgPitch =
          yinData.reduce((sum, frame) => sum + frame.pitch, 0) / yinData.length;
        const avgConfidence =
          yinData.reduce((sum, frame) => sum + frame.confidence, 0) /
          yinData.length;

        // yinThreshold.textContent = avgFrame.threshold.toFixed(3);
        // yinPitchValue.textContent =
        //   avgPitch > 0
        //     ? `${Math.round(avgPitch)}Hz (${(avgConfidence * 100).toFixed(0)}%)`
        //     : "No pitch";

        const validPitches = yinData.filter((frame) => frame.pitch > 0);
        if (validPitches.length > 0) {
          const minPitch = Math.min(
            yinParams.minFreq,
            ...validPitches.map((f) => f.pitch)
          );
          const maxPitch = Math.max(...validPitches.map((f) => f.pitch));
          const pitchRange = Math.max(maxPitch - minPitch, 50);

          // Draw pitch line with confidence-based opacity
          ctx.lineWidth = 3;

          let lastValidX = -1;
          let lastValidY = -1;

          for (let i = 0; i < yinData.length; i++) {
            const frame = yinData[i];
            if (frame.pitch > 0) {
              // Map time index to canvas width (matching spectrogram time axis)
              const timeRatio = i / (yinData.length - 1);
              const x = timeRatio * width;

              // Map pitch to independent Y-axis (full canvas height for pitch range)
              const pitchRatio = (frame.pitch - minPitch) / pitchRange;
              const y = height - pitchRatio * height;

              // Color based on confidence with bright, visible colors
              const alpha = Math.max(0.1, frame.confidence);
              const strokeAlpha = 0;

              // Use bright yellow/white for high visibility over spectrogram
              ctx.strokeStyle = `rgba(255, 255, 0, ${strokeAlpha})`;
              ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;

              // Draw line connecting consecutive valid pitch points
              if (lastValidX >= 0 && lastValidY >= 0) {
                ctx.beginPath();
                ctx.moveTo(lastValidX, lastValidY);
                ctx.lineTo(x, y);
                ctx.stroke();
              }

              // Draw confidence dots
              ctx.beginPath();
              ctx.arc(x, y, 3, 0, 2 * Math.PI);
              ctx.fill();

              lastValidX = x;
              lastValidY = y;
            } else {
              // Reset line drawing when pitch is invalid
              lastValidX = -1;
              lastValidY = -1;
            }
          }

          // Draw pitch range labels on the overlay
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          ctx.font = "12px Inter";
          ctx.textAlign = "left";
          ctx.fillText(`${Math.round(maxPitch)}Hz`, 5, 20);
          ctx.fillText(`${Math.round(minPitch)}Hz`, 5, height - 10);
        } else {
          ctx.fillStyle = "#9CA3AF";
          ctx.font = "14px Inter";
          ctx.textAlign = "center";
          ctx.fillText("No pitch detected", width / 2, height / 2);
        }
      }
    </script>
  </body>
</html>
