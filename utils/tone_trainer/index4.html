<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tone Analyzer for Mandarin Practice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      /* Style for the canvas to make it responsive and sharp */
      canvas {
        width: 100%;
        height: 300px;
        background-color: #111827; /* bg-gray-900 */
        border-radius: 0.5rem;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }
      /* Custom styles for range sliders */
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 8px;
        background: #4b5563; /* bg-gray-600 */
        border-radius: 5px;
        outline: none;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      input[type="range"]:hover {
        opacity: 1;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #3b82f6; /* bg-blue-500 */
        cursor: pointer;
        border-radius: 50%;
      }
      input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #3b82f6; /* bg-blue-500 */
        cursor: pointer;
        border-radius: 50%;
      }
    </style>
  </head>
  <body
    class="bg-gray-800 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4"
  >
    <div class="w-full max-w-4xl mx-auto">
      <div class="text-center mb-6">
        <h1 class="text-3xl md:text-4xl font-bold text-white">Tone Analyzer</h1>
        <p class="text-lg text-gray-400 mt-2">
          For practicing Mandarin Chinese pronunciation
        </p>
      </div>

      <!-- Status Message -->
      <div
        id="status"
        class="text-center mb-4 p-3 rounded-lg bg-gray-700 transition-all duration-300"
      >
        <p id="instructions" class="text-lg font-medium text-blue-300">
          Hold the
          <kbd
            class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg"
            >Space</kbd
          >
          key to record
        </p>
      </div>

      <!-- UI Controls -->
      <div
        id="controls"
        class="mt-6 grid grid-cols-1 md:grid-cols-4 gap-6 bg-gray-700/50 p-6 rounded-lg"
      >
        <div class="flex-1/2">
          <button
            id="playAgainBtn"
            class="mt-3 px-4 py-2 bg-blue-800 hover:bg-blue-700 text-gray-300 font-medium rounded-lg transition-colors duration-200 hidden"
            onclick="playLastRecording()"
          >
            ðŸ”Š Play Again
          </button>
        </div>
        <div>
          <label
            for="colorScheme"
            class="block mb-2 text-sm font-medium text-gray-300"
            >Color Scheme</label
          >
          <select
            id="colorScheme"
            class="bg-gray-600 border border-gray-500 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-1"
          >
            <option value="viridis">Viridis</option>
            <option value="plasma">Plasma</option>
            <option value="hot">Hot</option>
            <option value="grayscale">Grayscale</option>
          </select>
        </div>
        <div>
          <label
            for="brightness"
            class="block mb-2 text-sm font-medium text-gray-300"
            >Brightness</label
          >
          <input
            type="range"
            id="brightness"
            min="-100"
            max="100"
            value="0"
            class="w-full"
          />
        </div>
        <div>
          <label
            for="contrast"
            class="block mb-2 text-sm font-medium text-gray-300"
            >Contrast</label
          >
          <input
            type="range"
            id="contrast"
            min="0"
            max="3"
            value="1"
            step="0.1"
            class="w-full"
          />
        </div>
      </div>

      <!-- Spectrogram Canvas -->
      <div class="w-full bg-gray-900 rounded-lg shadow-lg p-2">
        <h3 class="text-white text-lg font-medium mb-2 px-2">Spectrogram</h3>
        <canvas id="spectrogramCanvas"></canvas>
      </div>

      <!-- Pitch Ã— Strength Product Chart -->
      <div class="w-full bg-gray-900 rounded-lg shadow-lg p-2 mt-4">
        <h3 class="text-white text-lg font-medium mb-2 px-2">
          Pitch Ã— Strength Product
        </h3>
        <canvas id="productCanvas"></canvas>
      </div>

      <!-- Pitch Chart -->
      <div class="w-full bg-gray-900 rounded-lg shadow-lg p-2 mt-4">
        <h3 class="text-white text-lg font-medium mb-2 px-2">
          Average Pitch Over Time
        </h3>
        <canvas id="pitchCanvas"></canvas>
      </div>

      <!-- Audio Strength Chart -->
      <div class="w-full bg-gray-900 rounded-lg shadow-lg p-2 mt-4">
        <h3 class="text-white text-lg font-medium mb-2 px-2">
          Audio Strength Over Time
        </h3>
        <canvas id="strengthCanvas"></canvas>
      </div>
    </div>

    <script>
      // DOM Elements
      const instructions = document.getElementById("instructions");
      const statusDiv = document.getElementById("status");
      const playAgainBtn = document.getElementById("playAgainBtn");
      const canvas = document.getElementById("spectrogramCanvas");
      const canvasCtx = canvas.getContext("2d");
      const pitchCanvas = document.getElementById("pitchCanvas");
      const pitchCanvasCtx = pitchCanvas.getContext("2d");
      const strengthCanvas = document.getElementById("strengthCanvas");
      const strengthCanvasCtx = strengthCanvas.getContext("2d");
      const productCanvas = document.getElementById("productCanvas");
      const productCanvasCtx = productCanvas.getContext("2d");
      const controls = document.getElementById("controls");
      const colorSchemeSelect = document.getElementById("colorScheme");
      const brightnessSlider = document.getElementById("brightness");
      const contrastSlider = document.getElementById("contrast");

      // Audio & State Variables
      let audioContext;
      let mediaRecorder;
      let isRecording = false;
      let audioChunks = [];
      let spectrogramData = [];
      let pitchData = [];
      let strengthData = [];
      let lastAudioBuffer = null;

      // Visualization Settings
      let settings = {
        colorScheme: "viridis",
        brightness: 0,
        contrast: 1,
      };

      // --- ANALYSIS CONSTANTS (EDITED FOR HIGHER RESOLUTION) ---
      // Increased FFT_SIZE for better frequency (vertical) resolution.
      const FFT_SIZE = 4096 * 2;
      // The maximum frequency (in Hz) to display. This focuses the view on the vocal range.
      const MAX_FREQ_HZ = 1300;
      // is about how often we do the analysis. The system collects audio into a buffer, and every time the buffer is full, it runs the analysis.
      const BUFFER_SIZE = 256;

      // --- COLOR MAPS ---
      const COLOR_MAPS = {
        viridis: [
          [68, 1, 84],
          [72, 40, 120],
          [62, 74, 137],
          [49, 104, 142],
          [38, 130, 142],
          [31, 158, 137],
          [53, 183, 121],
          [109, 205, 89],
          [180, 222, 44],
          [253, 231, 37],
        ],
        plasma: [
          [13, 8, 135],
          [72, 1, 163],
          [120, 1, 168],
          [163, 29, 151],
          [201, 62, 122],
          [230, 99, 90],
          [249, 139, 64],
          [254, 183, 43],
          [240, 226, 33],
        ],
        hot: [
          [0, 0, 0],
          [255, 0, 0],
          [255, 255, 0],
          [255, 255, 255],
        ],
        grayscale: [
          [0, 0, 0],
          [255, 255, 255],
        ],
      };

      function interpolateColor(c1, c2, factor) {
        const result = c1.slice();
        for (let i = 0; i < 3; i++) {
          result[i] = Math.round(result[i] + factor * (c2[i] - result[i]));
        }
        return result;
      }

      function getColor(value, schemeName) {
        const map = COLOR_MAPS[schemeName];
        const scaledValue = (value / 255) * (map.length - 1);
        const colorIndex = Math.floor(scaledValue);
        const factor = scaledValue - colorIndex;

        if (colorIndex >= map.length - 1) {
          return map[map.length - 1];
        }
        return interpolateColor(map[colorIndex], map[colorIndex + 1], factor);
      }

      // --- PITCH DETECTION FROM SPECTROGRAM DATA ---
      function computeWeightedAverageFreq(freqData, sampleRate) {
        // Focus on vocal fundamental frequency range (80-400 Hz)
        const minFreq = 80;
        const maxFreq = MAX_FREQ_HZ;
        const fftSize = FFT_SIZE;

        const minBin = Math.floor((minFreq * fftSize) / sampleRate);
        const maxBin = Math.floor((maxFreq * fftSize) / sampleRate);

        let weightedSum = 0;
        let totalWeight = 0;
        let maxMagnitude = 0;

        // Find maximum in range for thresholding
        for (let i = minBin; i < maxBin && i < freqData.length; i++) {
          if (freqData[i] > maxMagnitude) {
            maxMagnitude = freqData[i];
          }
        }

        // Only consider frequencies above threshold
        const threshold = maxMagnitude * 0.3;

        for (let i = minBin; i < maxBin && i < freqData.length; i++) {
          if (freqData[i] > threshold) {
            const freq = (i * sampleRate) / fftSize;
            const magnitude = freqData[i];

            weightedSum += freq * magnitude * magnitude; // Square for emphasis
            totalWeight += magnitude * magnitude;
          }
        }

        if (totalWeight > 0 && maxMagnitude > 20) {
          // Minimum energy threshold
          return weightedSum / totalWeight;
        }

        return 0; // No clear pitch
      }

      function analyzePitchTrends(pitches) {
        const validPitches = pitches.filter((p) => p > 0);
        if (validPitches.length < 5)
          return { overallTrend: "stable", avgPitch: 0, range: 0 };

        const avgPitch =
          validPitches.reduce((a, b) => a + b, 0) / validPitches.length;
        const minPitch = Math.min(...validPitches);
        const maxPitch = Math.max(...validPitches);
        const range = maxPitch - minPitch;

        // Calculate overall trend using linear regression
        let sumX = 0,
          sumY = 0,
          sumXY = 0,
          sumXX = 0;
        let n = 0;

        for (let i = 0; i < pitches.length; i++) {
          if (pitches[i] > 0) {
            sumX += i;
            sumY += pitches[i];
            sumXY += i * pitches[i];
            sumXX += i * i;
            n++;
          }
        }

        if (n < 2) return { overallTrend: "stable", avgPitch, range };

        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const slopeThreshold = (avgPitch * 0.05) / pitches.length; // 5% change over duration

        let overallTrend = "stable";
        if (slope > slopeThreshold) {
          overallTrend = "rising";
        } else if (slope < -slopeThreshold) {
          overallTrend = "falling";
        }

        return { overallTrend, avgPitch, range, slope };
      }

      // --- EVENT LISTENERS ---
      window.addEventListener("load", () => {
        controls.style.display = "none";
      });

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault(); // Always prevent space bar scrolling
          if (!isRecording) {
            startRecording();
          }
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          e.preventDefault(); // Always prevent space bar scrolling
          if (isRecording) {
            stopRecording();
          }
        }
      });

      colorSchemeSelect.addEventListener("change", (e) => {
        settings.colorScheme = e.target.value;
        if (spectrogramData.length > 0) {
          drawSpectrogram();
          drawPitchChart();
          drawStrengthChart();
          drawProductChart();
        }
      });
      brightnessSlider.addEventListener("input", (e) => {
        settings.brightness = parseInt(e.target.value, 10);
        if (spectrogramData.length > 0) {
          drawSpectrogram();
          drawPitchChart();
          drawStrengthChart();
          drawProductChart();
        }
      });
      contrastSlider.addEventListener("input", (e) => {
        settings.contrast = parseFloat(e.target.value);
        if (spectrogramData.length > 0) {
          drawSpectrogram();
          drawPitchChart();
          drawStrengthChart();
          drawProductChart();
        }
      });

      // --- CORE AUDIO FUNCTIONS ---
      async function startRecording() {
        if (isRecording) return;
        isRecording = true;
        audioChunks = [];

        statusDiv.classList.remove("bg-gray-700");
        statusDiv.classList.add("bg-red-500");
        instructions.textContent = "Recording...";

        try {
          // Ensure AudioContext is created by user gesture
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          }
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = (event) => {
            audioChunks.push(event.data);
          };
          mediaRecorder.onstop = processAudio;
          mediaRecorder.start();
        } catch (err) {
          console.error("Error accessing microphone:", err);
          instructions.textContent =
            "Microphone access denied. Please allow access and try again.";
          statusDiv.classList.remove("bg-red-500");
          statusDiv.classList.add("bg-yellow-600");
          isRecording = false;
        }
      }

      function stopRecording() {
        if (!isRecording || !mediaRecorder) return;
        mediaRecorder.stop();

        // Clean up media stream tracks
        if (mediaRecorder.stream) {
          mediaRecorder.stream.getTracks().forEach((track) => track.stop());
        }

        isRecording = false;
        statusDiv.classList.remove("bg-red-500");
        statusDiv.classList.add("bg-blue-500");
        instructions.textContent = "Analyzing...";
      }

      function processAudio() {
        const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const audioBuffer = await audioContext.decodeAudioData(
              e.target.result
            );
            // Initialize data arrays (will be filled during spectrogram analysis)
            pitchData = [];
            strengthData = [];
            lastAudioBuffer = audioBuffer; // Store for replay
            analyzeAndDraw(audioBuffer);
            playAudio(audioBuffer);
          } catch (err) {
            console.error("Error decoding audio data:", err);
            instructions.textContent =
              "Could not process audio. Please try again.";
          }
        };
        reader.readAsArrayBuffer(audioBlob);
      }

      function playAudio(audioBuffer) {
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start(0);
      }

      function playLastRecording() {
        if (lastAudioBuffer && audioContext) {
          playAudio(lastAudioBuffer);
        }
      }

      function analyzeAndDraw(audioBuffer) {
        const offlineCtx = new OfflineAudioContext(
          audioBuffer.numberOfChannels,
          audioBuffer.length,
          audioBuffer.sampleRate
        );
        const source = offlineCtx.createBufferSource();
        source.buffer = audioBuffer;

        const analyser = offlineCtx.createAnalyser();
        analyser.fftSize = FFT_SIZE; // Use the new higher resolution FFT size
        analyser.smoothingTimeConstant = 0;

        // Decreased buffer size for better time (horizontal) resolution.
        const bufferSize = BUFFER_SIZE;
        const processor = offlineCtx.createScriptProcessor(bufferSize, 1, 1);

        const freqData = new Uint8Array(analyser.frequencyBinCount);
        spectrogramData = [];

        processor.onaudioprocess = (e) => {
          analyser.getByteFrequencyData(freqData);
          spectrogramData.push(new Uint8Array(freqData));

          // Compute weighted average frequency for pitch
          const pitch = computeWeightedAverageFreq(
            freqData,
            audioContext.sampleRate
          );
          pitchData.push(pitch);

          // Compute RMS (audio strength) from time domain data
          const inputData = e.inputBuffer.getChannelData(0);
          const rms = Math.sqrt(
            inputData.reduce((sum, val) => sum + val * val, 0) /
              inputData.length
          );
          strengthData.push(rms);
        };

        source.connect(analyser);
        analyser.connect(processor);
        processor.connect(offlineCtx.destination);

        source.start(0);

        offlineCtx
          .startRendering()
          .then(() => {
            console.log(
              `Analysis complete. Got ${spectrogramData.length} time slices.`
            );
            statusDiv.classList.remove("bg-blue-500");
            statusDiv.classList.add("bg-gray-700");
            instructions.innerHTML =
              'Hold the <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Space</kbd> key to record';
            controls.style.display = "grid";
            drawSpectrogram();
            drawPitchChart();
            drawStrengthChart();
            drawProductChart();
            playAgainBtn.classList.remove("hidden"); // Show play again button
          })
          .catch((err) => {
            console.error("Offline rendering failed:", err);
            instructions.textContent = "Error during analysis.";
          });
      }

      function drawSpectrogram() {
        const numSlices = spectrogramData.length;
        if (numSlices === 0) return;

        // --- EDITED FOR FOCUSED VIEW ---
        // Calculate how many frequency bins to show to focus on the vocal range.
        const freqPerBin = audioContext.sampleRate / FFT_SIZE;
        const relevantBins = Math.ceil(MAX_FREQ_HZ / freqPerBin);
        const totalBins = spectrogramData[0].length;
        const finalBinsToDraw = Math.min(relevantBins, totalBins);

        canvas.width = numSlices;
        canvas.height = finalBinsToDraw;

        const imageData = canvasCtx.createImageData(
          canvas.width,
          canvas.height
        );
        const data = imageData.data;

        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const value = spectrogramData[x][y];
            const color = getColor(value, settings.colorScheme);

            let r =
              settings.contrast * (color[0] - 128) + 128 + settings.brightness;
            let g =
              settings.contrast * (color[1] - 128) + 128 + settings.brightness;
            let b =
              settings.contrast * (color[2] - 128) + 128 + settings.brightness;

            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));

            const pixelIndex = ((canvas.height - 1 - y) * canvas.width + x) * 4;
            data[pixelIndex] = r;
            data[pixelIndex + 1] = g;
            data[pixelIndex + 2] = b;
            data[pixelIndex + 3] = 255;
          }
        }
        canvasCtx.putImageData(imageData, 0, 0);
      }

      function drawPitchChart() {
        if (pitchData.length === 0) return;

        // Set canvas size
        pitchCanvas.width = pitchCanvas.offsetWidth;
        pitchCanvas.height = 180; // Increased for indicators

        const ctx = pitchCanvasCtx;
        const width = pitchCanvas.width;
        const chartHeight = 120; // Reserve space for indicators
        const indicatorHeight = 60;

        // Clear canvas
        ctx.fillStyle = "#111827";
        ctx.fillRect(0, 0, width, pitchCanvas.height);

        // Analyze pitch trends
        const analysis = analyzePitchTrends(pitchData);

        // Filter out zero values (no pitch detected)
        const validPitches = pitchData.filter((p) => p > 0);
        if (validPitches.length === 0) {
          ctx.fillStyle = "#9CA3AF";
          ctx.font = "16px Inter";
          ctx.textAlign = "center";
          ctx.fillText("No clear pitch detected", width / 2, chartHeight / 2);
          return;
        }

        const minPitch = Math.min(...validPitches);
        const maxPitch = Math.max(...validPitches);
        const pitchRange = Math.max(maxPitch - minPitch, 50); // At least 50Hz range

        // Draw reference line for average pitch
        const avgY =
          chartHeight -
          ((analysis.avgPitch - minPitch) / pitchRange) * chartHeight;
        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, avgY);
        ctx.lineTo(width, avgY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw pitch line with color coding
        ctx.lineWidth = 3;

        let lastValidX = null,
          lastValidY = null;
        for (let i = 0; i < pitchData.length; i++) {
          if (pitchData[i] > 0) {
            const x = (i / (pitchData.length - 1)) * width;
            const y =
              chartHeight -
              ((pitchData[i] - minPitch) / pitchRange) * chartHeight;

            // Color based on relative pitch level
            const relativeToAvg =
              (pitchData[i] - analysis.avgPitch) / analysis.avgPitch;
            if (relativeToAvg > 0.1) {
              ctx.strokeStyle = "#EF4444"; // Red for high
            } else if (relativeToAvg < -0.1) {
              ctx.strokeStyle = "#10B981"; // Green for low
            } else {
              ctx.strokeStyle = "#3B82F6"; // Blue for medium
            }

            ctx.beginPath();
            if (lastValidX !== null) {
              ctx.moveTo(lastValidX, lastValidY);
              ctx.lineTo(x, y);
              ctx.stroke();
            }
            lastValidX = x;
            lastValidY = y;
          }
        }

        // Draw indicators at bottom
        const indicatorY = chartHeight + 20;

        // Stats
        ctx.fillStyle = "#9CA3AF";
        ctx.font = "12px Inter";
        ctx.textAlign = "right";
        ctx.fillText(
          `Avg: ${Math.round(analysis.avgPitch)}Hz`,
          width - 10,
          indicatorY - 5
        );
        ctx.fillText(
          `Range: ${Math.round(analysis.range)}Hz`,
          width - 10,
          indicatorY + 10
        );

        // Frequency labels on left
        ctx.fillStyle = "#6B7280";
        ctx.font = "10px Inter";
        ctx.textAlign = "left";
        ctx.fillText(`${Math.round(maxPitch)}Hz`, 5, 15);
        ctx.fillText(`${Math.round(analysis.avgPitch)}Hz`, 5, avgY + 3);
        ctx.fillText(`${Math.round(minPitch)}Hz`, 5, chartHeight - 5);
      }

      function drawStrengthChart() {
        if (strengthData.length === 0) return;

        // Set canvas size
        strengthCanvas.width = strengthCanvas.offsetWidth;
        strengthCanvas.height = 120;

        const ctx = strengthCanvasCtx;
        const width = strengthCanvas.width;
        const height = strengthCanvas.height;

        // Clear canvas
        ctx.fillStyle = "#111827";
        ctx.fillRect(0, 0, width, height);

        // Analyze strength data
        const maxStrength = Math.max(...strengthData);
        const avgStrength =
          strengthData.reduce((a, b) => a + b, 0) / strengthData.length;

        if (maxStrength === 0) {
          ctx.fillStyle = "#9CA3AF";
          ctx.font = "16px Inter";
          ctx.textAlign = "center";
          ctx.fillText("No audio signal detected", width / 2, height / 2);
          return;
        }

        // Draw grid lines
        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 1; i < 4; i++) {
          const y = (height / 4) * i;
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
        }
        ctx.stroke();

        // Draw average line
        const avgY = height - (avgStrength / maxStrength) * height;
        ctx.strokeStyle = "#374151";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, avgY);
        ctx.lineTo(width, avgY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw strength bars
        const barWidth = width / strengthData.length;

        for (let i = 0; i < strengthData.length; i++) {
          const x = i * barWidth;
          const barHeight = (strengthData[i] / maxStrength) * height;
          const y = height - barHeight;

          // Color based on strength level
          const strengthRatio = strengthData[i] / maxStrength;
          let color;
          if (strengthRatio > 0.7) {
            color = "#EF4444"; // Red for loud
          } else if (strengthRatio > 0.3) {
            color = "#F59E0B"; // Yellow for medium
          } else {
            color = "#10B981"; // Green for quiet
          }

          ctx.fillStyle = color;
          ctx.fillRect(x, y, barWidth - 1, barHeight);
        }

        // Labels
        ctx.fillStyle = "#6B7280";
        ctx.font = "10px Inter";
        ctx.textAlign = "left";
        ctx.fillText("Max", 5, 15);
        ctx.fillText("Avg", 5, avgY + 3);
        ctx.fillText("Min", 5, height - 15);

        // Stats
        ctx.fillStyle = "#9CA3AF";
        ctx.font = "10px Inter";
        ctx.textAlign = "right";
        ctx.fillText(`Peak: ${(maxStrength * 100).toFixed(1)}%`, width - 5, 15);
        ctx.fillText(`Avg: ${(avgStrength * 100).toFixed(1)}%`, width - 5, 25);
      }

      function computePitchStrengthProduct() {
        if (pitchData.length === 0 || strengthData.length === 0) return [];

        const productData = [];
        const minLength = Math.min(pitchData.length, strengthData.length);

        for (let i = 0; i < minLength; i++) {
          const pitch = pitchData[i] || 0;
          const strength = strengthData[i] || 0;

          // Normalize pitch to 0-1 range (using typical vocal range 80-400 Hz)
          const normalizedPitch =
            pitch > 0 ? Math.min(1, Math.max(0, (pitch - 80) / 320)) : 0;

          // Product of normalized pitch and strength
          const product = normalizedPitch * strength;
          productData.push(product);
        }

        return productData;
      }

      function drawProductChart() {
        const productData = computePitchStrengthProduct();
        if (productData.length === 0) return;

        // Set canvas size
        productCanvas.width = productCanvas.offsetWidth;
        productCanvas.height = 120;

        const ctx = productCanvasCtx;
        const width = productCanvas.width;
        const height = productCanvas.height;

        // Clear canvas
        ctx.fillStyle = "#111827";
        ctx.fillRect(0, 0, width, height);

        // Analyze product data
        const maxProduct = Math.max(...productData);
        const avgProduct =
          productData.reduce((a, b) => a + b, 0) / productData.length;

        if (maxProduct === 0) {
          ctx.fillStyle = "#9CA3AF";
          ctx.font = "16px Inter";
          ctx.textAlign = "center";
          ctx.fillText("No vocal activity detected", width / 2, height / 2);
          return;
        }

        // Draw grid lines
        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 1; i < 4; i++) {
          const y = (height / 4) * i;
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
        }
        ctx.stroke();

        // Draw average line
        const avgY = height - (avgProduct / maxProduct) * height;
        ctx.strokeStyle = "#374151";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, avgY);
        ctx.lineTo(width, avgY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw product curve
        ctx.strokeStyle = "#8B5CF6"; // Purple color for the product
        ctx.lineWidth = 2;
        ctx.beginPath();

        let lastValidX = null,
          lastValidY = null;
        for (let i = 0; i < productData.length; i++) {
          const x = (i / (productData.length - 1)) * width;
          const y = height - (productData[i] / maxProduct) * height;

          if (productData[i] > 0) {
            if (lastValidX === null) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
            lastValidX = x;
            lastValidY = y;
          }
        }
        ctx.stroke();

        // Fill area under curve
        ctx.fillStyle = "rgba(139, 92, 246, 0.2)"; // Semi-transparent purple
        ctx.beginPath();
        ctx.moveTo(0, height);

        for (let i = 0; i < productData.length; i++) {
          const x = (i / (productData.length - 1)) * width;
          const y = height - (productData[i] / maxProduct) * height;
          ctx.lineTo(x, y);
        }
        ctx.lineTo(width, height);
        ctx.closePath();
        ctx.fill();

        // Labels
        ctx.fillStyle = "#6B7280";
        ctx.font = "10px Inter";
        ctx.textAlign = "left";
        ctx.fillText("Max", 5, 15);
        ctx.fillText("Avg", 5, avgY + 3);
        ctx.fillText("Min", 5, height - 15);

        // Stats
        ctx.fillStyle = "#9CA3AF";
        ctx.font = "10px Inter";
        ctx.textAlign = "right";
        ctx.fillText(`Peak: ${(maxProduct * 1000).toFixed(0)}`, width - 5, 15);
        ctx.fillText(`Avg: ${(avgProduct * 1000).toFixed(0)}`, width - 5, 25);
      }
    </script>
  </body>
</html>
